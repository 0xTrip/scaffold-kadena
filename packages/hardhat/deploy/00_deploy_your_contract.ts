import { HardhatRuntimeEnvironment } from "hardhat/types";
import { DeployFunction } from "hardhat-deploy/types";
import { Contract } from "ethers";
import * as fs from "fs";
import * as path from "path";

/**
 * Updates the frontend's deployedContracts.ts file with the new deployment
 */
function updateDeployedContracts(networkName: string, chainId: number, contractName: string, contractAddress: string, abi: any[]) {
  const contractsFilePath = path.join(__dirname, "../../nextjs/contracts/deployedContracts.ts");
  
  let deployedContracts: Record<number, Record<string, { address: string; abi: any[] }>> = {};
  
  // Read existing contracts if file exists
  if (fs.existsSync(contractsFilePath)) {
    try {
      const fileContent = fs.readFileSync(contractsFilePath, "utf8");
      // Extract the deployedContracts object from the file
      const match = fileContent.match(/const deployedContracts = ({[\s\S]*?}) as const;/);
      if (match) {
        // Parse the JavaScript object (not JSON)
        deployedContracts = eval(`(${match[1]})`);
      }
    } catch (error) {
      console.log("Could not parse existing deployedContracts.ts, creating new one");
      deployedContracts = {};
    }
  }
  
  // Update with new deployment
  if (!deployedContracts[chainId]) {
    deployedContracts[chainId] = {};
  }
  
  deployedContracts[chainId][contractName] = {
    address: contractAddress,
    abi: abi,
  };
  
  // Generate the new file content
  const fileContent = `/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

const deployedContracts = ${JSON.stringify(deployedContracts, null, 2)} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;
  
  // Write the updated file
  fs.writeFileSync(contractsFilePath, fileContent);
  console.log(`âœ… Updated deployedContracts.ts for ${networkName} (Chain ID: ${chainId})`);
}

/**
 * Deploys a contract named "YourContract" using the deployer account and
 * constructor arguments set to the deployer address
 *
 * @param hre HardhatRuntimeEnvironment object.
 */
const deployYourContract: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const { deployer } = await hre.getNamedAccounts();
  const { deploy } = hre.deployments;

  const deployment = await deploy("YourContract", {
    from: deployer,
    // Contract constructor arguments
    args: [deployer],
    log: true,
    // autoMine: can be passed to the deploy function to make the deployment process faster on local networks by
    // automatically mining the contract deployment transaction. There is no effect on live networks.
    autoMine: true,
  });

  // Get the deployed contract to interact with it after deploying.
  const yourContract = await hre.ethers.getContract<Contract>("YourContract", deployer);
  console.log("ðŸ‘‹ Initial greeting:", await yourContract.greeting());

  // Update the frontend contracts file
  const chainId = await hre.ethers.provider.getNetwork().then(n => Number(n.chainId));
  updateDeployedContracts(
    hre.network.name,
    chainId,
    "YourContract",
    deployment.address,
    deployment.abi || []
  );
};

export default deployYourContract;

// Tags are useful if you have multiple deploy files and only want to run one of them.
// e.g. yarn deploy --tags YourContract
deployYourContract.tags = ["YourContract"];