// Create this new file: scripts/deployToRemoteChains.ts
import { chainweb, network, ethers, artifacts } from "hardhat";
import type { DeployedContractsOnChains } from "hardhat-kadena/src/utils";
import fs from "fs";
import path from "path";

/**
 * Generate deployedContracts.ts file for frontend
 */
async function generateDeployedContractsFile(deployments: any[]) {
  const contractName: string = "YourContract";
  const deploymentsByChain: Record<number, DeployedContractsOnChains> = {};
  const deployedContracts: Record<string, any> = {};

  // Get et the ABI from compilation artifacts
  const artifact = await artifacts.readArtifact(contractName);
  console.log("deployments in generateDeployedContractsFile", deployments);

  // Create a map of deployments by chain ID for easy lookup

  for (const deployment of deployments) {
    deploymentsByChain[deployment.chain] = deployment;
  }

  // Process deployments using runOverChains for consistency
  await chainweb.runOverChains(async chainId => {
    // No need for explicit chainweb chain switching, runOverChains does that for us
    console.log("network.config.chainId", network.config.chainId);

    // Skip chains that weren't in our successful deployments
    if (!deploymentsByChain[chainId]) {
      console.log(`No deployment for chain ${chainId}, skipping verification`);
      return;
    }

    const deployment = deploymentsByChain[chainId];
    deployedContracts[network.config.chainId] = {
      YourContract: {
        address: deployment.address,
        abi: artifact.abi, // Use the ABI from compilation artifacts
      },
    };
  });

  const contractsDir = path.join(__dirname, "../../nextjs/contracts");
  const filePath = path.join(contractsDir, "deployedContracts.ts");

  const fileContent = `/**
 * This file is autogenerated by Scaffold-Kadena.
 * You should not edit it manually or your changes might be overwritten.
 */
import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

const deployedContracts = ${JSON.stringify(deployedContracts, null, 2)} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;

  fs.writeFileSync(filePath, fileContent);
  console.log("âœ… Generated deployedContracts.ts");
}

async function main() {
  console.log("Remote deployment starting...");

  const chains = await chainweb.getChainIds();
  console.log("chains,", chains);
  await chainweb.switchChain(chains[0]);

  // Now the signer will be available because __RUNTIME_DEPLOYER_PRIVATE_KEY was set!
  const [deployer] = await ethers.getSigners();
  console.log("Remote deployer:", deployer.address);

  const deployed = await chainweb.deployContractOnChains({
    name: "YourContract",
    constructorArgs: [deployer.address], // No explicit signer needed!
  });

  if (deployed.deployments.length === 0) {
    console.log("No contracts deployed");
    return;
  }

  const successfulDeployments = deployed.deployments.filter(d => d !== null);
  console.log("Successful deployments:", successfulDeployments);

  if (successfulDeployments.length > 0) {
    console.log(`Contract successfully deployed to ${successfulDeployments.length} chains`);
    await generateDeployedContractsFile(successfulDeployments);
  }
}

main().catch(console.error);
